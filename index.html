<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Onda - Pelota sin texto</title>
  <style>
    html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;
      background:#cfefff; /* fondo azul claro */
      display:flex;align-items:center;justify-content:center}
    .wrap{width:920px;max-width:95vw;padding:18px;box-sizing:border-box}
    canvas{display:block;width:100%;height:480px;border-radius:8px;background:transparent;box-shadow:0 6px 18px rgba(0,0,0,0.08)}
    .error{position:fixed;left:12px;top:12px;padding:8px 12px;background:#fee9e9;color:#900;border-radius:6px;border:1px solid #f2c2c2;z-index:999}
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="c"></canvas>
  </div>

  <script>
  (function () {
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const DPR = window.devicePixelRatio || 1;

    // Parámetros de la animación
    const A = 80;           // amplitud vertical (px)
    const freqPos = 0.9;    // frecuencia posición (Hz)
    const baseR = 80;       // radio base (px)
    const freqScale = 1.2;  // frecuencia escala (Hz)

    let paused = false;
    window.addEventListener('keydown', (e) => { if (e.code === 'Space') { e.preventDefault(); paused = !paused; } });

    function resizeCanvas() {
      // El canvas CSS controla tamaño visual; aquí ajustamos el buffer a DPR
      const rect = canvas.getBoundingClientRect();
      if (rect.width === 0 || rect.height === 0) {
        // establecer tamaño por defecto si no hay medida todavía
        canvas.style.width = '100%';
        canvas.style.height = '480px';
      }
      const w = canvas.clientWidth || 920;
      const h = canvas.clientHeight || 480;
      canvas.width = Math.floor(w * DPR);
      canvas.height = Math.floor(h * DPR);
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Cargar imagen (Bola.png debe estar en la misma carpeta)
    const img = new Image();
    let imgLoaded = false;
    img.onload = () => { imgLoaded = true; };
    img.onerror = () => { showError('No se pudo cargar "Bola.png". Comprueba que esté en la misma carpeta y que el nombre coincida.'); };
    img.src = 'Bola.png';

    function showError(msg) {
      let el = document.querySelector('.error');
      if (!el) {
        el = document.createElement('div');
        el.className = 'error';
        document.body.appendChild(el);
      }
      el.textContent = msg;
    }

    // Control de tiempo para pausar con suavidad
    let elapsed = 0;
    let lastTS = null;

    function drawFrame(ts) {
      if (lastTS === null) lastTS = ts;
      const dt = (ts - lastTS) / 1000;
      lastTS = ts;
      if (!paused) elapsed += dt;
      const t = elapsed;

      // asegurar buffer correcto
      resizeCanvas();

      const W = canvas.width / DPR;
      const H = canvas.height / DPR;

      // limpiar y fondo suave
      ctx.clearRect(0, 0, W, H);
      const g = ctx.createLinearGradient(0, 0, 0, H);
      g.addColorStop(0, 'rgba(255,255,255,0.06)');
      g.addColorStop(1, 'rgba(0,0,0,0.02)');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, W, H);

      // posición y escala (sin y cos)
      const y = H / 2 + A * Math.sin(2 * Math.PI * freqPos * t);
      const scale = 1 + 0.4 * Math.cos(2 * Math.PI * freqScale * t); // ~0.6 .. 1.4
      const r = baseR * scale;
      const x = W / 2;

      // sombra según altura (solo visual)
      const floorY = H * 0.82;
      const yNorm = Math.max(0, Math.min(1, (floorY - y) / (A + baseR)));
      const shadowW = Math.max(12, 20 + 90 * (1 - yNorm));
      ctx.beginPath();
      ctx.ellipse(x, floorY + 8, shadowW, shadowW * 0.35, 0, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(0,0,0,0.18)';
      ctx.fill();

      if (imgLoaded) {
        // dibujar imagen centrada, escalada (sin texto ni etiquetas)
        ctx.drawImage(img, x - r, y - r, 2 * r, 2 * r);

        // contorno suave opcional
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(0,0,0,0.06)';
        ctx.stroke();
      } else {
        // fallback: círculo simple (sin texto)
        ctx.beginPath();
        ctx.fillStyle = '#ffcc99';
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(0,0,0,0.06)';
        ctx.stroke();
      }

      requestAnimationFrame(drawFrame);
    }

    requestAnimationFrame(drawFrame);

  })();
  </script>
</body>
</html>
